Преобразуйте одним запросом дерево, представленное структурными метками ltree в дерево, представленное в виде вложенных множеств.

У вас есть таблица KeywordLtree в которой записано небольшое дерево с помощью структурных меток.

CREATE TABLE KeywordLtree(id INT PRIMARY KEY, value TEXT, path ltree);
Его корневая вершина имеет идентификатор 0 и пустой путь. Соседние вершины упорядочены в порядке возрастания идентификаторов.
Вы хотите написать один запрос, который сгенерирует вам представление этого же дерева в виде вложенных множеств.

Правила генерации левого и правого номеров:
Оба номера берутся из одной монотонно возрастающей последовательности,
начинающейся с 1, левый номер назначается сразу после входа в вершину при обходе в глубину, правый непосредственно перед возвращением к родителю.

Нужно написать запрос, в результате которого будут следующие столбцы, в порядке очередности:

id INT: идентификатор вершины, такой же как и в таблице KeywordLtree
value TEXT: значение, такое же как и в соответствующей строке в таблице KeywordLrree
lft BIGINT: левый номер вершины
rgt BIGINT: правый номер вершины
Тип BIGINT, скорее всего, получится автоматически, но вы можете явно привести результат оператором ::BIGINT.

Пример валидного, но неправильного решения:
SELECT id, value, 0::BIGINT AS lft, 50::BIGINT AS rgt 
FROM KeywordLtree;