Напишите запрос, считающий в дереве, хранимом в виде списков смежностей, для каждой вершины размер её поддерева.

У вас есть таблица, в которой записано случайное дерево из 50 вершин в виде списков смежностей.

CREATE TABLE Keyword(
  id INT PRIMARY KEY, 
  value TEXT, -- некое значение, не имеющее смысла для целей этой задачи
  parent_id INT REFERENCES Keyword DEFAULT NULL);

-- Пример таблицы
Keyword                   
id  parent_id value
-------------------
0   NULL      'qwerty'
1   0         'asdfg'
2   0         'zxcvb'
3   1         'yuiop'
4   1         'ghjkl'



Вам нужно для каждой вершины вычислить размер возглавляемого ей поддерева, включая саму вершину.
Для вышеприведённого примера результат получится таким:

id  subtree_size
-------------
0   5
1   3
2   1
3   1
4   1

Нужно написать запрос, в результате которого будут следующие столбцы, в порядке очередности:

id INT: идентификатор вершины, такой же как и в таблице Keyword
subtree_size BIGINT: размер поддерева, включая саму вершину.
Тип BIGINT, скорее всего, получится автоматически, но вы можете явно привести результат оператором ::BIGINT.

Пример валидного, но неправильного решения:

SELECT 0 as id, 50::BIGINT AS subtree_size;